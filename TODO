# todo 正在监听时，Ctrl+C不管用，非要浏览器访问一下才管用
# self.raw_request = self.rfile.readline(self.MAX_READS) # why this line blocks?
# todo 静态文件服务器，没有找到文件时应返回正确的错误

# pw.launch(('', 8180), flask_app) 没问题，不会阻塞

# make_server('', 8181, pwapp()).serve_forever() 也没问题，不会阻塞

# pwserver.launch(cfg_file='config.conf') 也没问题，不会阻塞

# pw.launch(('127.0.0.1', 8182), demoapp) 会阻塞，必须要强行中止进程以后客户端才收到响应

# pw.launch(('127.0.0.1', 8181), pwapp()) 也会阻塞，症状同上。

上述的阻塞情况，如果又有客户端发来请求，则上一次的阻塞就不阻塞了。

肯定是socket最后发送时的问题。

# s=skt();s.connect(('127.0.0.1', 8181));s.send(r);s.recv(65537); 每次都不阻塞

# 先 s=skt();s.connect(('127.0.0.1', 8181));
# 然后 s.send(r);s.recv(65537); 第一次不阻塞，第二次就阻塞了。

# s.connect(('127.0.0.1', 8181)); 报错：Socket is already connected

# !!!!!!! 又发现一个症状： 前面 s.recv 之后，再次执行s.recv(65537) 还能收到数据
# 第一次 recv 只接收到头部，第二次接收到body

# flush close 这两个方法什么时候该调用，以及放在父类还是子类，是值得仔细检查的

